unit fonctions_xml;

{$IFDEF FPC}
{$mode Delphi}
{$ENDIF}

interface

uses
  Classes, SysUtils,
{$IFDEF VERSIONS}
  fonctions_version,
{$ENDIF}
{$IFDEF FPC}
   XMLPropStorage,
{$ELSE}
   ALXMLDoc,
{$ENDIF}
  Forms;

const CST_FileExtension = '.xml';

{$IFDEF VERSIONS}
  gver_fonctions_XML : T_Version = ( Component : 'Librairie de fonctions XML' ;
                                     FileUnit : 'fonctions_xml' ;
              			                 Owner : 'Matthieu Giroux' ;
              			                 Comment : 'Gestion des données des objets dynamiques du composant Fenêtre principale.' + #13#10 + 'Il comprend une création de menus' ;
              			                 BugsStory :  'Version 0.1.0.0 : Création de l''unité.';
              			                 UnitType : 1 ;
              			                 Major : 0 ; Minor : 1 ; Release : 0 ; Build : 0 );

{$ENDIF}
function fb_LoadXMLFile ( const axdo_FichierXML : {$IFDEF FPC}TXMLPropStorage{$ELSE}TALXMLDocument{$ENDIF}; const as_FileXML : String ): Boolean;

var gs_ProjectFile : String = '';
    gs_entities    :String  = 'rootEntities' ;
    gs_Encoding    : String = 'ISO-8859-1';

function fs_getSoftInfo : String;
function fi_GetXMlNodeCount ( const axdo_FichierXML : {$IFDEF FPC}TXMLPropStorage{$ELSE}TALXMLDocument{$ENDIF}):Longint ;
function fnod_GetXMlNodes ( const axdo_FichierXML : {$IFDEF FPC}TXMLPropStorage{$ELSE}TALXMLDocument{$ENDIF}):{$IFDEF FPC}TComponent{$ELSE}TALXMLNodeList{$ENDIF};
function fnod_GetXMlNode ( const axdo_FichierXML : {$IFDEF FPC}TXMLPropStorage{$ELSE}TALXMLDocument{$ENDIF}; const ai_i : Longint):{$IFDEF FPC}TComponent{$ELSE}TALXMLNode{$ENDIF};
function fs_GetXMlNodeName ( const axdo_FichierXML : {$IFDEF FPC}TXMLPropStorage{$ELSE}TALXMLDocument{$ENDIF}; const ai_i : Longint):String ;
function fs_GetXMlNodeClass ( const axdo_FichierXML : {$IFDEF FPC}TXMLPropStorage{$ELSE}TALXMLDocument{$ENDIF}; const ai_i : Longint):String ;
function fs_getSoftFiles : String;


implementation

uses StrUtils, fonctions_init, U_Donnees, fonctions_string;


function fs_getSoftInfo : String;
Begin
  Result := fs_getSoftFiles + 'info' + DirectorySeparator ;
End;

function fs_getSoftFiles : String;
Begin
  Result := fs_getSoftDir + 'files' + DirectorySeparator ;
End;
function fb_RepareXML ( const as_FileXML : String ): Boolean;
var lstl_FileXML : TStringList;
    li_i, li_j, li_pos1, li_pos2 : LongInt;
    ls_Chaine : String ;
Begin
  lstl_FileXML := TStringlist.Create ;
  Result := False;
  try
    lstl_FileXML.LoadFromFile ( as_FileXML );
    if (pos ( '[', lstl_FileXML.Text ) > 0 ) Then
      Begin
        lstl_FileXML.Text := StringReplace ( lstl_FileXML.Text, '[', '/>'+#13#10+'<CROCHET>', [rfReplaceAll]);
        lstl_FileXML.Text := StringReplace ( lstl_FileXML.Text, ']>', '</CROCHET>', [rfReplaceAll]);
        Result := True;
      End;
    for li_i := 0 to lstl_FileXML.Count -1 do
      Begin
        ls_Chaine := lstl_FileXML [ li_i ];
        li_pos1 := pos ( '<', ls_Chaine );
        li_pos2 := pos ( '''', ls_Chaine);
        for li_j := li_pos1 + 1 to li_pos2 - 2 do
         if ls_Chaine [ li_j ] = ' ' Then
          Begin
            ls_Chaine [ li_j ]:= '_' ;
            Result := True;
          End;
         if ( li_pos2 > 0 ) and ( li_pos1 > 0 ) Then
           Begin
            li_pos1 := posEx ( '>', ls_Chaine, li_pos2 ) - 1;
            li_pos2 := posEx ( '''', ls_Chaine, li_pos2 + 1) + 1;
            if ( li_pos2 < li_pos1 ) Then
              Begin
                lstl_FileXML [ li_i ] := Copy ( ls_Chaine, 1, li_pos2 ) + Copy ( ls_Chaine, li_pos1, length ( ls_Chaine ))
                Result := True;
              End;
            End;
        if Result Then
          lstl_FileXML [ li_i ] := ls_Chaine ;
      End;
    if Result Then lstl_FileXML.SaveToFile ( as_FileXML );
  Except
  End;
End;
function fb_LoadXML ( const axdo_FichierXML : {$IFDEF FPC}TXMLPropStorage{$ELSE}TALXMLDocument{$ENDIF}; const as_FileXML : String ): Boolean;
Begin
{$IFDEF FPC}
   axdo_FichierXML.FileName := as_FileXML;
{$ELSE}
  try
    axdo_FichierXML.LoadFromFile ( as_FileXML );
    axdo_FichierXML.Active := True ;
  Except
  End;
  Result := axdo_FichierXML.Active;
{$ENDIF}
End;
function fb_LoadXMLFile ( const axdo_FichierXML : {$IFDEF FPC}TXMLPropStorage{$ELSE}TALXMLDocument{$ENDIF}; const as_FileXML : String ): Boolean;
Begin
  Result := fb_LoadXML ( axdo_FichierXML, as_FileXML );
  if not Result Then
    if fb_RepareXML ( as_FileXML ) Then
      Result := fb_LoadXML( axdo_FichierXML, as_FileXML );
End;

function fnod_GetXMlNodes ( const axdo_FichierXML : {$IFDEF FPC}TXMLPropStorage{$ELSE}TALXMLDocument{$ENDIF}):{$IFDEF FPC}TComponent{$ELSE}TALXMLNodeList{$ENDIF};
Begin
  Result := axdo_FichierXML.{$IFDEF FPC}Root{$ELSE}ChildNodes{$ENDIF};
End;

function fnod_GetXMlNode ( const axdo_FichierXML : {$IFDEF FPC}TXMLPropStorage{$ELSE}TALXMLDocument{$ENDIF}; const ai_i : Longint):{$IFDEF FPC}TComponent{$ELSE}TALXMLNode{$ENDIF};
Begin
  Result := axdo_FichierXML.{$IFDEF FPC}Components{$ELSE}ChildNodes{$ENDIF}[ai_i];
End;
function fs_GetXMlNodeName ( const axdo_FichierXML : {$IFDEF FPC}TXMLPropStorage{$ELSE}TALXMLDocument{$ENDIF}; const ai_i : Longint):String ;
Begin
  Result := axdo_FichierXML.{$IFDEF FPC}Components{$ELSE}ChildNodes{$ENDIF}[ai_i].{$IFDEF FPC}Name{$ELSE}NodeName{$ENDIF};
End;

function fs_GetXMlNodeClass ( const axdo_FichierXML : {$IFDEF FPC}TXMLPropStorage{$ELSE}TALXMLDocument{$ENDIF}; const ai_i : Longint):String ;
Begin
  Result := axdo_FichierXML.{$IFDEF FPC}Components{$ELSE}ChildNodes{$ENDIF}[ai_i].{$IFDEF FPC}ClassName{$ELSE}LocalName{$ENDIF};
End;

function fi_GetXMlNodeCount ( const axdo_FichierXML : {$IFDEF FPC}TXMLPropStorage{$ELSE}TALXMLDocument{$ENDIF}):Longint ;
Begin
  Result := axdo_FichierXML.{$IFDEF FPC}ComponentCount{$ELSE}ChildNodes.Count{$ENDIF};
End;

initialization
{$IFDEF VERSIONS}
  p_ConcatVersion ( gVer_fonctions_XML );
{$ENDIF}
end.
